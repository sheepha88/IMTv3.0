// Îç∞Ïù¥ÌÑ∞ Î™®Îç∏ Î∞è Ïä§ÌÜ†Î¶¨ÏßÄ Ïú†Ìã∏
const STORAGE_KEY = 'doc_archiving_state_v1';
const ROLES = ['Admin', 'Editor', 'Viewer'];

/**
 * state schema
 * {
 *   currentRole: 'Admin' | 'Editor' | 'Viewer',
 *   selectedFolderId: string,
 *   folders: Array<{ id, name, description, parentId, uploadRoles: string[], createdAt }>,
 *   files: Array<{ id, folderId, name, type, size, uploadedAt, ownerRole, viewRoles: string[], editRoles: string[] }>
 * }
 */

function loadState() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return null;
  try { return JSON.parse(raw); } catch (_) { return null; }
}

function saveState(state) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function createInitialState() {
  const rootId = crypto.randomUUID();
  const designId = crypto.randomUUID();
  const specsId = crypto.randomUUID();
  const qaId = crypto.randomUUID();

  return {
    currentRole: 'Admin',
    selectedFolderId: rootId,
    folders: [
      { id: rootId, name: 'ÌîÑÎ°úÏ†ùÌä∏ Î¨∏ÏÑú', description: 'ÌîÑÎ°úÏ†ùÌä∏ Ï†ÑÎ∞ò Î¨∏ÏÑú Î≥¥Í¥Ä', parentId: null, uploadRoles: ['Admin', 'Editor'], createdAt: Date.now() },
      { id: designId, name: 'Design', description: 'UI/UX ÏÇ∞Ï∂úÎ¨º', parentId: rootId, uploadRoles: ['Admin', 'Editor'], createdAt: Date.now() },
      { id: specsId, name: 'Specs', description: 'ÏöîÍµ¨ÏÇ¨Ìï≠/ÏÑ§Í≥Ñ Î¨∏ÏÑú', parentId: rootId, uploadRoles: ['Admin'], createdAt: Date.now() },
      { id: qaId, name: 'QA', description: 'ÌÖåÏä§Ìä∏ ÏºÄÏù¥Ïä§/Î¶¨Ìè¨Ìä∏', parentId: rootId, uploadRoles: ['Admin', 'Editor'], createdAt: Date.now() },
    ],
    files: [
      { id: crypto.randomUUID(), folderId: specsId, name: 'ÏöîÍµ¨ÏÇ¨Ìï≠Ï†ïÏùòÏÑú_v1.pdf', type: 'pdf', size: 124000, uploadedAt: Date.now(), ownerRole: 'Admin', viewRoles: ['Admin', 'Editor', 'Viewer'], editRoles: ['Admin'] },
      { id: crypto.randomUUID(), folderId: designId, name: 'Î©îÏù∏ÌôîÎ©¥-ÏôÄÏù¥Ïñ¥ÌîÑÎ†àÏûÑ.png', type: 'image', size: 560000, uploadedAt: Date.now(), ownerRole: 'Editor', viewRoles: ['Admin', 'Editor', 'Viewer'], editRoles: ['Admin', 'Editor'] },
      { id: crypto.randomUUID(), folderId: qaId, name: 'ÌöåÍ∑ÄÌÖåÏä§Ìä∏_Î¶¨Ìè¨Ìä∏.xlsx', type: 'excel', size: 89000, uploadedAt: Date.now(), ownerRole: 'Editor', viewRoles: ['Admin', 'Editor'], editRoles: ['Admin', 'Editor'] },
    ],
  };
}

function getState() {
  let state = loadState();
  if (!state) {
    state = createInitialState();
    saveState(state);
  }
  return state;
}

function setState(producer) {
  const state = getState();
  const next = producer(structuredClone(state));
  saveState(next);
  return next;
}

// Í∂åÌïú Ïú†Ìã∏
function canUploadToFolder(role, folder) {
  return role === 'Admin' || folder.uploadRoles.includes(role);
}
function canViewFile(role, file) {
  return role === 'Admin' || file.viewRoles.includes(role);
}
function canEditFile(role, file) {
  return role === 'Admin' || file.editRoles.includes(role);
}

// DOM refs
const roleSelect = document.getElementById('roleSelect');
const resetDataBtn = document.getElementById('resetDataBtn');
const folderTree = document.getElementById('folderTree');
const addFolderBtn = document.getElementById('addFolderBtn');
const editFolderBtn = document.getElementById('editFolderBtn');
const deleteFolderBtn = document.getElementById('deleteFolderBtn');

const uploadBtn = document.getElementById('uploadBtn');
const moveBtn = document.getElementById('moveBtn');
const deleteFileBtn = document.getElementById('deleteFileBtn');
const refreshBtn = document.getElementById('refreshBtn');
const searchInput = document.getElementById('searchInput');
const selectAllCheckbox = document.getElementById('selectAll');
const fileTableBody = document.getElementById('fileTableBody');
const infoPanel = document.getElementById('infoPanel');

// Dialog refs
const uploadDialog = document.getElementById('uploadDialog');
const uploadForm = document.getElementById('uploadForm');
const fileInput = document.getElementById('fileInput');
const viewRolesContainer = document.getElementById('viewRolesContainer');
const editRolesContainer = document.getElementById('editRolesContainer');
const confirmUploadBtn = document.getElementById('confirmUploadBtn');

const folderDialog = document.getElementById('folderDialog');
const folderForm = document.getElementById('folderForm');
const folderDialogTitle = document.getElementById('folderDialogTitle');
const folderNameInput = document.getElementById('folderNameInput');
const folderDescInput = document.getElementById('folderDescInput');
const folderUploadRolesContainer = document.getElementById('folderUploadRolesContainer');
const folderSaveBtn = document.getElementById('folderSaveBtn');

const moveDialog = document.getElementById('moveDialog');
const moveForm = document.getElementById('moveForm');
const moveFolderSelect = document.getElementById('moveFolderSelect');
const confirmMoveBtn = document.getElementById('confirmMoveBtn');

// View state
let currentSelection = new Set(); // file ids
let folderDialogMode = 'create'; // or 'edit'

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;
}

function renderRoleChips(viewRoles, editRoles) {
  const view = viewRoles.join(', ');
  const edit = editRoles.join(', ');
  return `<span class="badge">${view} / ${edit}</span>`;
}

function buildRoleCheckboxes(container, name, selectedRoles) {
  container.innerHTML = '';
  ROLES.forEach((role) => {
    const id = `${name}_${role}`;
    const label = document.createElement('label');
    label.innerHTML = `<input type="checkbox" id="${id}" value="${role}" ${selectedRoles.includes(role) ? 'checked' : ''}/> ${role}`;
    container.appendChild(label);
  });
}

function getCheckedRoles(container) {
  return Array.from(container.querySelectorAll('input[type="checkbox"]:checked')).map((c) => c.value);
}

function buildFolderOptions(selectEl, excludeId) {
  const state = getState();
  selectEl.innerHTML = '';
  state.folders.forEach((f) => {
    if (excludeId && f.id === excludeId) return;
    const opt = document.createElement('option');
    opt.value = f.id;
    opt.textContent = f.name;
    selectEl.appendChild(opt);
  });
}

function getFolderPath(folderId) {
  const state = getState();
  const parts = [];
  let cur = state.folders.find((f) => f.id === folderId);
  while (cur) {
    parts.unshift(cur.name);
    cur = cur.parentId ? state.folders.find((f) => f.id === cur.parentId) : null;
  }
  return parts.join(' / ');
}

// Renderers
function renderFolderTree() {
  const state = getState();
  const treeRoot = document.createDocumentFragment();
  const byParent = new Map();
  state.folders.forEach((f) => {
    const list = byParent.get(f.parentId) || [];
    list.push(f);
    byParent.set(f.parentId, list);
  });

  function renderLevel(parentId, depth) {
    const items = byParent.get(parentId) || [];
    items.sort((a, b) => a.name.localeCompare(b.name, 'ko'));
    items.forEach((f) => {
      const node = document.createElement('div');
      node.className = `tree-node ${state.selectedFolderId === f.id ? 'active' : ''}`;
      node.dataset.id = f.id;
      node.innerHTML = `
        <span class="tree-indent" style="padding-left:${depth * 12}px"></span>
        <span class="tree-toggle">üìÅ</span>
        <span class="tree-name">${f.name}</span>
        <span class="tree-meta">${f.uploadRoles.join(', ')} ÏóÖÎ°úÎìú</span>
      `;
      node.addEventListener('click', () => {
        setState((draft) => {
          draft.selectedFolderId = f.id;
          return draft;
        });
        currentSelection.clear();
        selectAllCheckbox.checked = false;
        refreshAll();
      });
      treeRoot.appendChild(node);
      renderLevel(f.id, depth + 1);
    });
  }

  folderTree.innerHTML = '';
  renderLevel(null, 0);
  folderTree.appendChild(treeRoot);
}

function renderFileTable() {
  const state = getState();
  const role = state.currentRole;
  const query = (searchInput.value || '').toLowerCase();
  const rows = state.files.filter((file) => file.folderId === state.selectedFolderId)
    .filter((file) => canViewFile(role, file))
    .filter((file) => file.name.toLowerCase().includes(query));

  fileTableBody.innerHTML = '';
  rows.sort((a, b) => a.name.localeCompare(b.name, 'ko'));
  rows.forEach((file) => {
    const tr = document.createElement('tr');
    tr.className = 'file-row';
    tr.dataset.id = file.id;
    tr.innerHTML = `
      <td><input type="checkbox" class="rowCheck" ${currentSelection.has(file.id) ? 'checked' : ''} /></td>
      <td>${file.name}</td>
      <td>${file.type}</td>
      <td>${formatBytes(file.size)}</td>
      <td>${new Date(file.uploadedAt).toLocaleString()}</td>
      <td>${file.ownerRole}</td>
      <td>${renderRoleChips(file.viewRoles, file.editRoles)}</td>
    `;

    tr.addEventListener('click', (e) => {
      if (e.target.closest('input[type="checkbox"]')) return;
      showInfoForFile(file.id);
    });
    tr.querySelector('.rowCheck').addEventListener('change', (e) => {
      if (e.target.checked) currentSelection.add(file.id);
      else currentSelection.delete(file.id);
      updateToolbarState();
    });

    fileTableBody.appendChild(tr);
  });

  selectAllCheckbox.checked = rows.length > 0 && rows.every((r) => currentSelection.has(r.id));
  updateToolbarState();
}

function showInfoForFolder(folderId) {
  const state = getState();
  const role = state.currentRole;
  const folder = state.folders.find((f) => f.id === folderId);
  const files = state.files.filter((file) => file.folderId === folderId && canViewFile(role, file));
  const totalSize = files.reduce((acc, f) => acc + f.size, 0);
  infoPanel.innerHTML = `
    <div class="info-block">
      <div class="kv">
        <div class="k">Ìè¥Îçî Í≤ΩÎ°ú</div><div class="v">${getFolderPath(folderId)}</div>
        <div class="k">Ìè¥Îçî Î™Ö</div><div class="v">${folder.name}</div>
        <div class="k">ÏÑ§Î™Ö</div><div class="v">${folder.description || '-'}</div>
        <div class="k">ÏóÖÎ°úÎìú Í∂åÌïú</div><div class="v">${folder.uploadRoles.join(', ')}</div>
        <div class="k">ÌååÏùº Ïàò</div><div class="v">${files.length}</div>
        <div class="k">Ï¥ù ÌÅ¨Í∏∞</div><div class="v">${formatBytes(totalSize)}</div>
        <div class="k">ÏÉùÏÑ±Ïùº</div><div class="v">${new Date(folder.createdAt).toLocaleString()}</div>
      </div>
    </div>
  `;
}

function showInfoForFile(fileId) {
  const state = getState();
  const file = state.files.find((f) => f.id === fileId);
  infoPanel.innerHTML = `
    <div class="info-block">
      <div class="kv">
        <div class="k">ÌååÏùº Î™Ö</div><div class="v">${file.name}</div>
        <div class="k">ÌòïÏãù</div><div class="v">${file.type}</div>
        <div class="k">ÌÅ¨Í∏∞</div><div class="v">${formatBytes(file.size)}</div>
        <div class="k">ÏóÖÎ°úÎìúÏùº</div><div class="v">${new Date(file.uploadedAt).toLocaleString()}</div>
        <div class="k">ÏÜåÏú†Ïûê</div><div class="v">${file.ownerRole}</div>
        <div class="k">Í∂åÌïú</div><div class="v">Î≥¥Í∏∞: ${file.viewRoles.join(', ')} | Ìé∏Ïßë: ${file.editRoles.join(', ')}</div>
        <div class="k">ÏúÑÏπò</div><div class="v">${getFolderPath(file.folderId)}</div>
      </div>
    </div>
  `;
}

function updateToolbarState() {
  const state = getState();
  const folder = state.folders.find((f) => f.id === state.selectedFolderId);
  const role = state.currentRole;
  const canUpload = canUploadToFolder(role, folder);
  const selectionFiles = state.files.filter((f) => currentSelection.has(f.id));
  const canMove = selectionFiles.length > 0 && selectionFiles.every((f) => canEditFile(role, f));
  const canDelete = canMove;
  uploadBtn.disabled = !canUpload;
  moveBtn.disabled = !canMove;
  deleteFileBtn.disabled = !canDelete;
}

function refreshAll() {
  const state = getState();
  roleSelect.value = state.currentRole;
  renderFolderTree();
  renderFileTable();
  showInfoForFolder(state.selectedFolderId);
}

// Event handlers
roleSelect.addEventListener('change', (e) => {
  setState((draft) => { draft.currentRole = e.target.value; return draft; });
  refreshAll();
});

resetDataBtn.addEventListener('click', () => {
  localStorage.removeItem(STORAGE_KEY);
  currentSelection.clear();
  refreshAll();
});

addFolderBtn.addEventListener('click', () => {
  folderDialogMode = 'create';
  folderDialogTitle.textContent = 'Ìè¥Îçî Ï∂îÍ∞Ä';
  folderNameInput.value = '';
  folderDescInput.value = '';
  buildRoleCheckboxes(folderUploadRolesContainer, 'folderUpload', ['Admin', 'Editor']);
  folderDialog.showModal();
});

editFolderBtn.addEventListener('click', () => {
  const state = getState();
  const folder = state.folders.find((f) => f.id === state.selectedFolderId);
  if (!folder) return;
  folderDialogMode = 'edit';
  folderDialogTitle.textContent = 'Ìè¥Îçî ÏàòÏ†ï';
  folderNameInput.value = folder.name;
  folderDescInput.value = folder.description || '';
  buildRoleCheckboxes(folderUploadRolesContainer, 'folderUpload', folder.uploadRoles);
  folderDialog.showModal();
});

deleteFolderBtn.addEventListener('click', () => {
  const state = getState();
  const currentId = state.selectedFolderId;
  const hasChildren = state.folders.some((f) => f.parentId === currentId);
  const hasFiles = state.files.some((f) => f.folderId === currentId);
  if (state.folders.find((f) => f.id === currentId)?.parentId === null) {
    alert('Î£®Ìä∏ Ìè¥ÎçîÎäî ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
    return;
  }
  if (hasChildren || hasFiles) {
    const ok = confirm('ÌïòÏúÑ Ìè¥Îçî ÎòêÎäî ÌååÏùºÏù¥ ÏûàÏäµÎãàÎã§. Î™®Îëê Ìï®Íªò ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?');
    if (!ok) return;
  }
  setState((draft) => {
    const removeIds = new Set([currentId]);
    // remove descendants
    let changed = true;
    while (changed) {
      changed = false;
      draft.folders.forEach((f) => {
        if (f.parentId && removeIds.has(f.parentId) && !removeIds.has(f.id)) { removeIds.add(f.id); changed = true; }
      });
    }
    draft.folders = draft.folders.filter((f) => !removeIds.has(f.id));
    draft.files = draft.files.filter((fi) => !removeIds.has(fi.folderId));
    const fallback = draft.folders.find((f) => f.parentId === null)?.id;
    draft.selectedFolderId = fallback || (draft.folders[0]?.id ?? null);
    return draft;
  });
  currentSelection.clear();
  refreshAll();
});

folderForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const uploadRoles = getCheckedRoles(folderUploadRolesContainer);
  if (uploadRoles.length === 0) {
    alert('ÏóÖÎ°úÎìú Í∂åÌïúÏùÄ ÏµúÏÜå 1Í∞ú Ïù¥ÏÉÅ ÏÑ†ÌÉùÌï¥Ïïº Ìï©ÎãàÎã§.');
    return;
  }
  if (folderDialogMode === 'create') {
    const name = folderNameInput.value.trim();
    if (!name) return;
    setState((draft) => {
      const id = crypto.randomUUID();
      draft.folders.push({ id, name, description: folderDescInput.value.trim(), parentId: draft.selectedFolderId, uploadRoles, createdAt: Date.now() });
      draft.selectedFolderId = id;
      return draft;
    });
  } else {
    setState((draft) => {
      const f = draft.folders.find((x) => x.id === draft.selectedFolderId);
      if (f) {
        f.name = folderNameInput.value.trim();
        f.description = folderDescInput.value.trim();
        f.uploadRoles = uploadRoles;
      }
      return draft;
    });
  }
  folderDialog.close();
  refreshAll();
});

uploadBtn.addEventListener('click', () => {
  const state = getState();
  const folder = state.folders.find((f) => f.id === state.selectedFolderId);
  if (!canUploadToFolder(state.currentRole, folder)) {
    alert('ÏóÖÎ°úÎìú Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.');
    return;
  }
  buildRoleCheckboxes(viewRolesContainer, 'viewRoles', ['Admin', 'Editor', 'Viewer']);
  buildRoleCheckboxes(editRolesContainer, 'editRoles', ['Admin', 'Editor']);
  fileInput.value = '';
  uploadDialog.showModal();
});

uploadForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const files = Array.from(fileInput.files || []);
  const viewRoles = getCheckedRoles(viewRolesContainer);
  const editRoles = getCheckedRoles(editRolesContainer);
  if (files.length === 0) return uploadDialog.close();
  if (viewRoles.length === 0) { alert('Î≥¥Í∏∞ Í∂åÌïúÏùÄ ÏµúÏÜå 1Í∞ú Ïù¥ÏÉÅ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.'); return; }
  if (editRoles.length === 0) { alert('Ìé∏Ïßë Í∂åÌïúÏùÄ ÏµúÏÜå 1Í∞ú Ïù¥ÏÉÅ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.'); return; }
  setState((draft) => {
    const folderId = draft.selectedFolderId;
    files.forEach((f) => {
      draft.files.push({
        id: crypto.randomUUID(),
        folderId,
        name: f.name,
        type: f.type || inferTypeFromName(f.name),
        size: f.size || 0,
        uploadedAt: Date.now(),
        ownerRole: getState().currentRole,
        viewRoles: [...viewRoles],
        editRoles: [...editRoles],
      });
    });
    return draft;
  });
  uploadDialog.close();
  refreshAll();
});

function inferTypeFromName(name) {
  const ext = name.split('.').pop()?.toLowerCase();
  if (!ext) return 'file';
  if (['png','jpg','jpeg','gif','webp','bmp','svg'].includes(ext)) return 'image';
  if (['pdf'].includes(ext)) return 'pdf';
  if (['doc','docx'].includes(ext)) return 'word';
  if (['xls','xlsx','csv'].includes(ext)) return 'excel';
  if (['ppt','pptx'].includes(ext)) return 'ppt';
  if (['txt','md'].includes(ext)) return 'text';
  return ext;
}

moveBtn.addEventListener('click', () => {
  const state = getState();
  const selectionFiles = state.files.filter((f) => currentSelection.has(f.id));
  if (selectionFiles.length === 0) return;
  // Ìé∏Ïßë Í∂åÌïú ÌôïÏù∏
  if (!selectionFiles.every((f) => canEditFile(state.currentRole, f))) {
    alert('ÏÑ†ÌÉùÎêú ÌååÏùº Ï§ë Ïù¥Îèô Í∂åÌïúÏù¥ ÏóÜÎäî ÌååÏùºÏù¥ ÏûàÏäµÎãàÎã§.');
    return;
  }
  buildFolderOptions(moveFolderSelect, null);
  moveFolderSelect.value = state.selectedFolderId;
  moveDialog.showModal();
});

moveForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const targetFolderId = moveFolderSelect.value;
  setState((draft) => {
    draft.files.forEach((f) => {
      if (currentSelection.has(f.id)) f.folderId = targetFolderId;
    });
    return draft;
  });
  moveDialog.close();
  currentSelection.clear();
  refreshAll();
});

deleteFileBtn.addEventListener('click', () => {
  const state = getState();
  const selectionFiles = state.files.filter((f) => currentSelection.has(f.id));
  if (selectionFiles.length === 0) return;
  if (!selectionFiles.every((f) => canEditFile(state.currentRole, f))) {
    alert('ÏÑ†ÌÉùÎêú ÌååÏùº Ï§ë ÏÇ≠Ï†ú Í∂åÌïúÏù¥ ÏóÜÎäî ÌååÏùºÏù¥ ÏûàÏäµÎãàÎã§.');
    return;
  }
  const ok = confirm(`${selectionFiles.length}Í∞ú ÌååÏùºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`);
  if (!ok) return;
  setState((draft) => {
    draft.files = draft.files.filter((f) => !currentSelection.has(f.id));
    return draft;
  });
  currentSelection.clear();
  refreshAll();
});

refreshBtn.addEventListener('click', () => refreshAll());
searchInput.addEventListener('input', () => renderFileTable());
selectAllCheckbox.addEventListener('change', () => {
  const state = getState();
  const role = state.currentRole;
  const query = (searchInput.value || '').toLowerCase();
  const rows = state.files.filter((file) => file.folderId === state.selectedFolderId)
    .filter((file) => canViewFile(role, file))
    .filter((file) => file.name.toLowerCase().includes(query));
  if (selectAllCheckbox.checked) {
    rows.forEach((r) => currentSelection.add(r.id));
  } else {
    rows.forEach((r) => currentSelection.delete(r.id));
  }
  renderFileTable();
});

// Ï¥àÍ∏∞ Î†åÎçî
refreshAll();

